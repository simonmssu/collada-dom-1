// File generated by CPPExt (Transient)
//
//
//                     Copyright (C) 1991 - 2000 by  
//                      Matra Datavision SA.  All rights reserved.
//  
//                     Copyright (C) 2001 - 2004 by
//                     Open CASCADE SA.  All rights reserved.
// 
// This file is part of the Open CASCADE Technology software.
//
// This software may be distributed and/or modified under the terms and
// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
// and appearing in the file LICENSE included in the packaging of this file.
//  
// This software is distributed on an "AS IS" basis, without warranty of any
// kind, and Open CASCADE SA hereby disclaims all such warranties,
// including without limitation, any warranties of merchantability, fitness
// for a particular purpose or non-infringement. Please see the License for
// the specific terms and conditions governing rights and limitations under the
// License.

#ifndef _Standard_Type_HeaderFile
#define _Standard_Type_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Handle_Standard_Type_HeaderFile
#include <Handle_Standard_Type.hxx>
#endif

#ifndef _Standard_CString_HeaderFile
#include <Standard_CString.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _Standard_KindOfType_HeaderFile
#include <Standard_KindOfType.hxx>
#endif
#ifndef _Standard_Address_HeaderFile
#include <Standard_Address.hxx>
#endif
#ifndef _Standard_Transient_HeaderFile
#include <Standard_Transient.hxx>
#endif
#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _Standard_OStream_HeaderFile
#include <Standard_OStream.hxx>
#endif
class Standard_TypeMismatch;
class Standard_NoSuchObject;
class Standard_OutOfRange;
class Standard_AncestorIterator;



//!   The class <Type> provides services to find out information <br>
//!   about a type defined in CDL. <br>
class Standard_Type : public Standard_Transient {

public:
 // Methods PUBLIC
 // 


//!   Returns the type name of <me>. <br>
Standard_EXPORT   Standard_CString Name() const;


//!   Returns the size of <me> in bytes. <br>
Standard_EXPORT   Standard_Integer Size() const;


//!   The constructor for a imported type. <br>
Standard_EXPORT Standard_Type(const Standard_CString aName,const Standard_Integer aSize);


//!   The constructor for a standard C++ class <br>
Standard_EXPORT Standard_Type(const Standard_CString aName);


//!   The constructor for a primitive. <br>
Standard_EXPORT Standard_Type(const Standard_CString aName,const Standard_Integer aSize,const Standard_Integer aNumberOfParent,const Standard_Address aAncestors);


//!   The constructor for an enumeration. <br>
Standard_EXPORT Standard_Type(const Standard_CString aName,const Standard_Integer aSize,const Standard_Integer aNumberOfElement,const Standard_Integer aNumberOfParent,const Standard_Address anAncestors,const Standard_Address aElements);


//!   The constructor for a class. <br>
Standard_EXPORT Standard_Type(const Standard_CString aName,const Standard_Integer aSize,const Standard_Integer aNumberOfParent,const Standard_Address anAncestors,const Standard_Address aFields);


//!   Returns "True", if <me> is the same as <aOther>, <br>
//!   or inherits from <aOther>. <br>
//!   Note that multiple inheritance is not supported. <br>
Standard_EXPORT   Standard_Boolean SubType(const Handle(Standard_Type)& aOther) const;


//!   Returns "True", if <me> or one of its ancestors has the name <br>
//!   equal to theName. <br>
//!   Note that multiple inheritance is not supported. <br>
Standard_EXPORT   Standard_Boolean SubType(const Standard_CString theName) const;


//!   Returns "True", if the type is imported. <br>
Standard_EXPORT   Standard_Boolean IsImported() const;


//!   Returns "True", if the type is a primitive. <br>
Standard_EXPORT   Standard_Boolean IsPrimitive() const;


//!   Returns "True", if the type is an "Enumeration". <br>
Standard_EXPORT   Standard_Boolean IsEnumeration() const;


//!   Returns "True", if the type is a "Class". <br>
Standard_EXPORT   Standard_Boolean IsClass() const;


//!   Returns the number of direct parents of the class. <br>
//! <br>
Standard_EXPORT   Standard_Integer NumberOfParent() const;


//!   Returns the number of ancestors of the class. <br>
//! <br>
Standard_EXPORT   Standard_Integer NumberOfAncestor() const;


//!   Prints the Information about type. <br>
Standard_EXPORT   void ShallowDump() const;


//!   Prints the Information about type. <br>
Standard_EXPORT   void ShallowDump(Standard_OStream& S) const;


//!   Prints on the stream <s> the name of Type. <br>
//!  Warning: <br>
//!   The operator "OStream& operator<< (Standard_OStream&, <br>
//!                                      Handle(Standard_Type)&)" <br>
//!   is implemented. (This operator uses the method Print) <br>
//! <br>
Standard_EXPORT   void Print(Standard_OStream& s) const;
Standard_EXPORT     void operator<<(Standard_OStream& s) const  {  Print(s); }  
//Standard_EXPORT ~Standard_Type();


friend class Standard_AncestorIterator;


 // Type management
 //
 Standard_EXPORT const Handle(Standard_Type)& DynamicType() const;
 //Standard_EXPORT Standard_Boolean	       IsKind(const Handle(Standard_Type)&) const;

protected:

 // Methods PROTECTED
 // 


 // Fields PROTECTED
 //


private: 

 // Methods PRIVATE
 // 


//!   Returns the address of the ancestors array. It can be used only by <br>
//!   AncestorIterator. <br>
Standard_EXPORT   Standard_Address Ancestors() const;

//!    Just for inline. <br>
//! <br>
  void InLineDummy() const;


 // Fields PRIVATE
 //
Standard_CString myName;
Standard_Integer mySize;
Standard_KindOfType myKind;
Standard_Integer myNumberOfParent;
Standard_Integer myNumberOfAncestor;
Standard_Address myAncestors;


};


#include <Standard_Type.lxx>



// other Inline functions and methods (like "C++: function call" methods)
//
inline void ShallowDump(const Handle_Standard_Type& me) {
 me->ShallowDump();
}

inline void ShallowDump(const Handle_Standard_Type& me,Standard_OStream& S) {
 me->ShallowDump(S);
}



#endif
